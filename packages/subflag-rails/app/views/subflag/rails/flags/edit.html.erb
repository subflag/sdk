<div class="flex justify-between items-center mb-10">
  <h2 style="font-size: 20px;">Edit Flag: <span class="mono"><%= @flag.key %></span></h2>
  <a href="<%= flags_path %>" class="btn">Back to Flags</a>
</div>

<div class="card">
  <h2>Basic Settings</h2>
  <%= render "form", flag: @flag %>
</div>

<div class="card">
  <h2>Targeting Rules</h2>
  <p class="text-muted mb-10">Rules are evaluated in order. First match wins. If no rules match, the default value is used.</p>

  <div id="rules-container">
    <!-- Rules rendered by JS -->
  </div>

  <button type="button" class="btn mt-10" onclick="addRule()">+ Add Rule</button>

  <input type="hidden" name="targeting_rules_json" id="targeting-rules-json" value="<%= @flag.targeting_rules.to_json %>">

  <div class="mt-10">
    <button type="button" class="btn btn-primary" onclick="saveRules()">Save Rules</button>
  </div>
</div>

<div class="card">
  <h2>Test Rules</h2>
  <p class="text-muted mb-10">Enter a context (JSON) to test which value would be returned.</p>

  <%= form_with url: test_flag_path(@flag), method: :post, local: true do |f| %>
    <div class="form-group">
      <%= f.label :context, "Test Context (JSON)" %>
      <%= f.text_area :context, rows: 4, placeholder: '{"email": "test@company.com", "role": "admin"}', value: @test_context&.to_json, class: "mono" %>
    </div>
    <%= f.submit "Test", class: "btn" %>
  <% end %>

  <% if defined?(@test_result) && @test_result %>
    <div class="mt-10" style="padding: 15px; background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 4px;">
      <strong>Result:</strong> <span class="mono"><%= @test_result.inspect %></span>
    </div>
  <% end %>
</div>

<style>
  .rule { border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-bottom: 10px; background: #fafafa; }
  .rule-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
  .rule-value { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
  .rule-value input { width: 200px; }
  .rule-percentage { display: flex; gap: 10px; align-items: center; margin-bottom: 10px; }
  .rule-percentage input { width: 80px; }
  .rule-logic { margin-bottom: 10px; }
  .rule-logic label { margin-right: 15px; }
  .condition { display: flex; gap: 8px; align-items: center; margin-bottom: 8px; }
  .condition select, .condition input { padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px; }
  .condition input[type="text"] { width: 180px; }
  .remove-btn { background: none; border: none; color: #dc3545; cursor: pointer; font-size: 18px; padding: 0 5px; }
  .remove-btn:hover { color: #c82333; }
</style>

<%= javascript_tag nonce: true do %>
  const OPERATORS = [
    { value: "EQUALS", label: "equals" },
    { value: "NOT_EQUALS", label: "not equals" },
    { value: "IN", label: "in (comma-separated)" },
    { value: "NOT_IN", label: "not in" },
    { value: "CONTAINS", label: "contains" },
    { value: "STARTS_WITH", label: "starts with" },
    { value: "ENDS_WITH", label: "ends with" },
    { value: "GREATER_THAN", label: ">" },
    { value: "LESS_THAN", label: "<" },
    { value: "MATCHES", label: "matches (regex)" }
  ];

  let rules = [];

  function init() {
    const saved = document.getElementById("targeting-rules-json").value;
    if (saved) {
      try {
        rules = JSON.parse(saved) || [];
      } catch (e) {
        rules = [];
      }
    }
    renderRules();
  }

  function renderRules() {
    const container = document.getElementById("rules-container");
    container.innerHTML = rules.map((rule, ruleIndex) => renderRule(rule, ruleIndex)).join("");
  }

  function renderRule(rule, ruleIndex) {
    const conditions = rule.conditions?.conditions || [];
    const logicType = rule.conditions?.type || "AND";
    const percentage = rule.percentage;
    const hasConditions = conditions.length > 0;

    return `
      <div class="rule" data-rule-index="${ruleIndex}">
        <div class="rule-header">
          <strong>Rule ${ruleIndex + 1}</strong>
          <button type="button" class="remove-btn" onclick="removeRule(${ruleIndex})">&times;</button>
        </div>
        <div class="rule-value">
          <label>Return value:</label>
          <input type="text" value="${escapeHtml(rule.value || '')}" onchange="updateRuleValue(${ruleIndex}, this.value)" placeholder="value when matched">
        </div>
        <div class="rule-percentage">
          <label>Percentage rollout:</label>
          <input type="number" min="0" max="100" value="${percentage ?? ''}" onchange="updateRulePercentage(${ruleIndex}, this.value)" placeholder="">
          <span>% of users</span>
          <small style="color: #666;">(leave empty to match all)</small>
        </div>
        <div class="rule-logic" ${!hasConditions && percentage ? 'style="opacity: 0.5;"' : ''}>
          <label><input type="radio" name="logic-${ruleIndex}" value="AND" ${logicType === 'AND' ? 'checked' : ''} onchange="updateLogic(${ruleIndex}, 'AND')"> ALL match</label>
          <label><input type="radio" name="logic-${ruleIndex}" value="OR" ${logicType === 'OR' ? 'checked' : ''} onchange="updateLogic(${ruleIndex}, 'OR')"> ANY match</label>
        </div>
        <div class="conditions" id="conditions-${ruleIndex}">
          ${conditions.map((c, cIndex) => renderCondition(c, ruleIndex, cIndex)).join("")}
        </div>
        <button type="button" class="btn btn-sm" onclick="addCondition(${ruleIndex})">+ Add Condition</button>
        <small style="display: block; margin-top: 5px; color: #666;">${hasConditions && percentage ? 'User must match conditions AND be in percentage' : ''}</small>
      </div>
    `;
  }

  function renderCondition(condition, ruleIndex, condIndex) {
    const operatorOptions = OPERATORS.map(op =>
      `<option value="${op.value}" ${condition.operator === op.value ? 'selected' : ''}>${op.label}</option>`
    ).join("");

    const valueDisplay = Array.isArray(condition.value) ? condition.value.join(", ") : (condition.value || "");

    return `
      <div class="condition">
        <input type="text" placeholder="attribute" value="${escapeHtml(condition.attribute || '')}" onchange="updateCondition(${ruleIndex}, ${condIndex}, 'attribute', this.value)">
        <select onchange="updateCondition(${ruleIndex}, ${condIndex}, 'operator', this.value)">
          ${operatorOptions}
        </select>
        <input type="text" placeholder="value" value="${escapeHtml(valueDisplay)}" onchange="updateCondition(${ruleIndex}, ${condIndex}, 'value', this.value)">
        <button type="button" class="remove-btn" onclick="removeCondition(${ruleIndex}, ${condIndex})">&times;</button>
      </div>
    `;
  }

  function addRule() {
    rules.push({
      value: "",
      conditions: { type: "AND", conditions: [] }
    });
    renderRules();
  }

  function removeRule(index) {
    rules.splice(index, 1);
    renderRules();
  }

  function updateRuleValue(ruleIndex, value) {
    rules[ruleIndex].value = value;
  }

  function updateRulePercentage(ruleIndex, value) {
    if (value === '' || value === null) {
      delete rules[ruleIndex].percentage;
    } else {
      rules[ruleIndex].percentage = parseInt(value, 10);
    }
    renderRules();
  }

  function updateLogic(ruleIndex, type) {
    rules[ruleIndex].conditions.type = type;
  }

  function addCondition(ruleIndex) {
    if (!rules[ruleIndex].conditions.conditions) {
      rules[ruleIndex].conditions.conditions = [];
    }
    rules[ruleIndex].conditions.conditions.push({ attribute: "", operator: "EQUALS", value: "" });
    renderRules();
  }

  function removeCondition(ruleIndex, condIndex) {
    rules[ruleIndex].conditions.conditions.splice(condIndex, 1);
    renderRules();
  }

  function updateCondition(ruleIndex, condIndex, field, value) {
    const cond = rules[ruleIndex].conditions.conditions[condIndex];
    if (field === "value" && (cond.operator === "IN" || cond.operator === "NOT_IN")) {
      cond.value = value.split(",").map(v => v.trim());
    } else {
      cond[field] = value;
    }
  }

  function saveRules() {
    // Clean up rules before saving - filter out invalid rules
    const cleanedRules = rules.map(rule => {
      const cleaned = { value: rule.value };
      if (rule.percentage !== undefined && rule.percentage !== null && rule.percentage !== '') {
        cleaned.percentage = rule.percentage;
      }
      const conditions = rule.conditions?.conditions?.filter(c => c.attribute && c.operator);
      if (conditions && conditions.length > 0) {
        cleaned.conditions = { type: rule.conditions?.type || "AND", conditions };
      }
      return cleaned;
    }).filter(rule => rule.conditions || rule.percentage !== undefined);

    const formData = new FormData();
    formData.append("flag[key]", "<%= @flag.key %>");
    formData.append("flag[value]", "<%= @flag.value %>");
    formData.append("flag[value_type]", "<%= @flag.value_type %>");
    formData.append("flag[enabled]", "<%= @flag.enabled? %>");
    formData.append("flag[targeting_rules]", JSON.stringify(cleanedRules));

    fetch("<%= flag_path(@flag) %>", {
      method: "PATCH",
      headers: {
        "X-CSRF-Token": "<%= form_authenticity_token %>",
      },
      body: formData,
      redirect: "manual"
    }).then(response => {
      if (response.ok || response.type === "opaqueredirect" || response.status === 302) {
        window.location.reload();
      } else {
        alert("Failed to save rules: " + response.status);
      }
    }).catch(err => {
      alert("Error saving rules: " + err.message);
    });
  }

  function escapeHtml(str) {
    const div = document.createElement("div");
    div.textContent = str;
    return div.innerHTML;
  }

  document.addEventListener("DOMContentLoaded", init);
<% end %>
